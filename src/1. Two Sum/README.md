這道題目要求我們從一個整數陣列 `nums` 中找出兩個數字，它們的和等於目標數字 `target`，並返回這兩個數字的索引。每個數字只能使用一次，且保證一定有唯一解。

### 解題思路解析：

1. **使用哈希表（`map`）加速查找** ：

* 這道題的關鍵點在於如何有效率地找到兩個數字的和等於目標值。直接暴力解法（雙重迴圈）會有 O(n^2) 的時間複雜度，對於較大的數組來說效率較低。因此，我們可以使用哈希表（`map`）來加速查找過程。

1. **一步到位地檢查每個數字是否已找到對應的配對** ：

* 我們可以遍歷 `nums` 陣列，對於每個元素 `num`，計算出與目標值相差的數字 `diff = target - num`。
* 然後，我們檢查 `diff` 是否已經存在於哈希表中。如果找到了，這說明 `num` 和對應的 `diff` 可以組成一個解，因為這兩個數的和等於 `target`。
* 若找不到，則將 `num` 和它的索引存入哈希表，這樣當我們繼續往後遍歷時，可以快速查找該數字的配對。

1. **時間和空間效率** ：

* 這種方法使用了一次遍歷來解決問題，因此時間複雜度是 O(n)，其中 n 是陣列長度。每次查找和插入哈希表的操作都是 O(1)。
* 空間複雜度是 O(n)，因為最壞情況下，哈希表需要存儲所有的數字。

---



### 解題步驟：

1. **初始化哈希表** ：`numToIndexMap` 用來存放每個數字以及其對應的索引，便於後續快速查找。
2. **遍歷陣列** ：對於每個數字 `num` 和它的索引 `i`，我們計算與目標 `target` 的差值 `diff`，即 `diff = target - num`。
3. **查找配對** ：檢查 `diff` 是否已存在於哈希表中：

* 如果存在，這表示當前數字和哈希表中的數字可以組成一個解，因此返回這兩個數字的索引。
* 如果不存在，則將當前數字和其索引加入到哈希表中，繼續往後遍歷。

1. **返回結果** ：當找到配對時，直接返回兩個數字的索引即可。

### 示例解釋：

假設有一個輸入陣列 `nums = [2, 7, 11, 15]`，目標 `target = 9`。

1. **遍歷第一個元素** ：

* `num = 2`, `diff = 9 - 2 = 7`。
* 在哈希表中找不到 7，因此將 `2` 加入哈希表，`numToIndexMap` 變為 `{2: 0}`。

1. **遍歷第二個元素** ：

* `num = 7`, `diff = 9 - 7 = 2`。
* 在哈希表中找到 `2`，其索引為 `0`，這說明 `7 + 2 = 9`，因此返回 `[0, 1]`。

### 時間和空間複雜度：

* **時間複雜度** ：O(n)，每個數字只需要被遍歷一次。
* **空間複雜度** ：O(n)，因為需要存儲最多 n 個數字及其索引在哈希表中。

這個方法既簡潔又高效，適合處理大規模數據。
